## 1.你认为java的优势是什么？
这种笼统的问题如果对某些知识点没有深入、系统的认识绝对会懵！
所以为什么经常碰到面试官问你一些空、大的问题？其实就是**考察你是否有形成体系的理解**
回到问题本身。我觉得可以从**跨平台、垃圾回收、生态**三个方面来阐述

### 跨平台
首先Java是跨平台的，不同平台执行的机器码是不一样的，而java因为中间加了一层JVM，所以可以做到一次编写多平台运行，即[Write once, Run anyWhere]
编译执行过程是先把java源码编译成字节码，字节码再由JVM解释执行或JIT编译执行，而因为JIT编译执行需要预热，所以还提供了AOT(Ahead-of-Time Compilation),
可以直接把字节码转换成机器码，来让程序重启之后迅速拉满战斗。

### 垃圾回收
java还提供垃圾自动回收功能，虽说手动管理内存意味着自由、精细化地掌控，但是很容易出错。
在内存系统较充裕的当下，将内存管理交给GC来做，减轻了编程负担，提升了开发效率

### 生态
Java的生态圈太全了，有非常丰富的第三方类库、网上全面的资料、企业级框架、各种中间件等等，总有一款适合你的业务需求

## 2.什么是Java的多态性？

### 回答重点
多态是指同一个接口或父类引用变量可以指向不同的对象实例，并根据实例指向的对象类型执行相应的方法。
它允许同一个方法在不同的对象上表现出不同的行为，面试对象编程的核心特性之一
#### 多态的优点：
* 通过多态，程序可以灵活的处理不同类型的对象，降低代码耦合度，增强系统的可扩展性。新增自子类或实现类时，无需修改原有点代码，只需通过接口或父类的引用
调用即可
### 扩展知识
#### 多态的意义
多态其实是一种抽象行为，它的主要作用是让程序员可以面对抽象编程而不是具体的实现类，这样写出来的代码扩展性会更强。
大家可能不理解什么是抽象什么是具体，举个例子
```java
class Person {
    void work() {
        System.out.println("工作");
    }
}

class Student extends Person {
    @Override
    void work() {
        System.out.println("上学");
    }
}

public class Test {
    public static void main(String[] args) {
        Person person = new Student();
        person.work(); // 输出 "上学"
    }
}
```
这样在使用的时候，对象都是person，但是new不同的实现类，表现的形式不同

#### 编译事多态和运行时多态
编译事多态和运行时多态是面向对象编程中多态性的两种实现方式，他们分别在不同的阶段决定方法的绑定。
* 编译时多态：通过方法重载实现，在编译时确定方法的调用
* 运行时多态：通过方法重写实现，在运行时确定方法的调用
##### 1.编译时多态
**编译时多态**：也称为**静态多态**，是在编译阶段确定方法的调用。编译时多态主要通过**方法重载**实现
**方法重载**：指在同一个类中定义多个方法，这些方法的名称相同但是参数列表不同（参数的类型和数量），
java编译器在编译时会根据方法调用时传入的参数类型和数量，来决定调用哪一个重载方法。
**示例**
```java
class Example {
    void display(int a) {
        System.out.println("Integer: " + a);
    }

    void display(double a) {
        System.out.println("Double: " + a);
    }

    void display(String a) {
        System.out.println("String: " + a);
    }
}

public class Main {
    public static void main(String[] args) {
        Example obj = new Example();
        obj.display(5);         // 调用 display(int a)
        obj.display(3.14);      // 调用 display(double a)
        obj.display("Hello");   // 调用 display(String a)
    }
}
```
例子中，编译器会根据方法传入的参数类型，决定调用哪个display方法

##### 2.运行时多态
**运行时多态**，也称为**动态多态**，是在运行时确定的方法调用。运行时多态通过**方法重写**实现。
**方法重写**：子类重写父类的一个或多个方法。通过父类引用调用方法时，实际执行的是子类重写后的方法，
这种多态性是在实际运行时根据实际的对象类型决定的。
**示例**
```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog(); // Animal reference but Dog object
        Animal myCat = new Cat(); // Animal reference but Cat object

        myDog.sound(); // 输出: Dog barks
        myCat.sound(); // 输出: Cat meows
    }
}
```

## 3.java中的参数传递是按值还是按引用？
#### Java只有值传递，不论是基本类型还是引用类型。
jvm内存有划分为栈和堆，局部变量和方法参数是在栈上分配的，引用类型占四个字节，基本类型看具体类型，例如long和double占8字节
而对象所占的空间是在堆中开辟的，引用类型变量存储的是对象在堆中的地址，并以此来访问对象，所以传递的时候可以理解成把变量存储的
地址传递过去，因此引用类型也是值传递。

![值传递](./images/值传递.png)

## 4.接口和抽象类有什么区别？
### 回答重点
接口和抽象类在设计动机上有所不同。
接口的设计是**自上而下**的，我们知道了某些行为，基于这些行为约束定义类接口，一些类需要有这些行为，因此实现对应的接口
抽象类的设计是**自下而上**的。我们写了很多类，发现它们之间有共性，有很多代码可以复用，因此将公共逻辑封装成一个抽象类，
减少代码冗余。
所谓的**自上而下**指的是先约定接口，再实现。而自下而上是先有一些类，才抽象了共同的父类，实际开发时，抽象接口更多的是承担
公共的业务逻辑，大多用于模板方法模式的公共业务逻辑机制

### 其他区别
* 方法实现
接口中的方法默认是public和abstract（java8之后可以设置default方法或者静态方法）
抽象类可以包含abstract方法（未实现）和具体方法（有实现），它允许子类继承并重用抽象类中的方法实现。
* 构造函数和成员变量
接口不能有构造函数，接口中的成员变量默认为public static final,即常量
抽象类可以包含构造函数，成员变量可以是不同的修饰符，并且可以不是常量
* 多继承
抽象类只能单继承，接口可以多个实现

### 扩展知识
#### 接口演变
* java8：引入了default和static方法，使接口不仅是方法的声明，还可以提供具体实现，default方法允许在接口中添加新的
方法实现，而不影响已有的实现类
* java9：引入类私有方法，允许在接口中定义私有方法，用于default方法的内部逻辑复用
* java14：引入了sealed接口（仅仅某些子类中使用），增强接口使用

## 5.为什么Java不支持多继承？
主要是多继承会产生菱形继承（也叫钻石继承）问题，java之父就是吸取C++他们的教训，因此在不支持多继承。
所谓菱形继承很好理解：
![菱形继承问题](./images/菱形继承问题.png)

B、C继承A，然后D又继承BC,假设此时要调用D内定义的A的方法，因为B和C都有不同的实现，此时就会出现歧义，不知道要调用哪个

## 6.Java中的序列化和反序列化是什么？
序列化其实就是将对象转化成可传输的字节序列格式，以便于存储和传输。
因为对象在JVM中可以认为是“立体”的，会有各种引用，比如在内存地址Ox1234引用了某某对象，那此时这个对象要传输到网络的另一端时候就需要把这些引用“压扁”。
因为网络的另一端的内存地址Ox1234可以没有某某对象，所以传输的对象需要包含这些信息，然后接收端将这些扁平的信息再反序列化得到对象。
所以，**反序列化就是将字节序列格式转换为对象的过程**。
![序列化与反序列化](./images/序列化与反序列化.png)
我再扩展一下Java 序列化。
>首先说一下Serializable，这个接口没有什么实际的含义，就是起标记作用。

来看下源码就很清楚了，除了String、数组和枚举之外，如果实现了这个接口就走writeOrdinaryObject，否则就序列化就抛错。

![序列化源码](./images/序列化底层源码.png)

上面的源码是来自于ObjectOutputStream类的private void writeObject0(Object obj, boolean unshared)方法，这个方法是一个辅助方法，用于处理对象的序列化。
在使用框架(例如Spring Boot)进行编程时，许多情况下即使类没有实现Serializable接口，也可以完成对象的序列化和反序列化。这是因为这些框架并没有使用原生的
ObjectOutputStream来处理序列化，而是使用了其他机制。
比如，Spring Boot默认的JSON序列化库Jackson使用JSON字符串作为中转格式，实现了对象的序列化和反序列化。然而，如果遇到使用ObjectOutputStream进行序列化的情况，
对象不实现Serializable接口就会报错。因此，为了兼容更多的场景，通常还是建议将需要序列化的类实现Serializable 接口。

>serialVersionUID 又有什么用?

private static final long serialVersionUID =1L;
想必经常会看到这样的代码，这个ID其实就是用来验证序列化的对象和反序列化对应的对象的ID是否是一致的。
所以这个ID 的数字其实不重要，无论是1L还是idea自动生成的，只要序列化的时候对象的serialVersionUID 和反序列化的时候对象的serialVersionUID 一致的话就行。
如果没有显式指定serialVersionUID，则编译器会根据类的相关信息自动生成一个，可以认为是一个指纹。
所以如果你没有定义一个serialVersionUID然后序列化一个对象之后，在反序列化之前把对象的类的结构改了，比如增加了一个成员变量，则此时的反序列化会失败。
因为类的结构变了，生成的指纹就变了，所以serialVersionUID 就不一致了。
所以serialVersionUID 就是起验证作用。
>Java 序列化不包含静态变量

简单地说就是序列化之后存储的内容不包含静态变量的值，看一下下面的代码就很清晰了。

![序列化与反序列化静态变量的验证](./images/序列化与反序列化静态变量的验证.png)

**总结**
序列化无法存储静态变量是因为，静态变量属于类级别的，与类的定义相关联。
更具体的说序列化是通过调用对象的writeObject方法和readObject来实将对象写入输出流和读取输入流的，
而静态变量由于不属于对象的一部分，因此调用这两个方法时候静态变量都不参与其中，也行成一开始说的序列化无法存储静态变量的值。

>为什么serialVersionUID被static修饰了还会被序列化?

serialVersionUID的序列化做了特殊处理，在序列化时，会将serialVersionUID序列化到二进制字节流中;在反序
列化时，也会解析它并做一致性判断

## 7.什么是java中的不可变类？
不可变类指的是无法修改对象的值，比如String就是典型的不可变类，当你创建一个String对象之后，这个对象就无法被修改。
因为无法被修改，所以像执行s += "a"; 这样的方法，其实返回的是一个新建的String对象，老的s指向的对象不会发生变化，
只是s的引用指向了新的对象而已。
所以不要在字符串拼接频繁的场景使用+来拼接，因为这样会频繁的创建对象。
不可变类的好处就是安全，因为知晓这个对象不可能会被修改，因此可以放心大胆的用，在多线程环境下也是线程安全的。
如何实现一个不可变类?
这个问题我被面试官问过，其实就参考String的设计就行。
String 类用 final修饰，表示无法被继承。
![string不可变类](./images/java不可变类.png)
String 本质是一个char 数组，然后用final修饰，不过final限制不了数组内部的数据，所以这还不够。
所以value 是用 private修饰的，并且没有暴露出set方法，这样外部其实就接触不到value所以无法修改。
当然还是有修改的需求，比如replace方法，所以这时候就需要返回一个新对象来作为结果。
**总结**一下就是私有化变量，使用private final 修饰变量，不要暴露set方法，即使有修改的需求也是返回一个新的对象。

## 8.Java中的Exception和Error有什么区别？
**Exception** 是程序正常运行过程中可以预料到的意外情况，应该被开发者捕获并且进行相应的处理。
**Error** 是指在正常情况下不太可能出现的情况，绝大部分的Error都会导致程序处于不正常、不可恢复的状态，也就是挂了。
所以不便也不需被开发者捕获，因为这个情况下你捕获了也无济于事。
Exception和Error都是继承了Throwable类，在Java代码中只有继承了Throwable类的实例才可以被throw或者被catch。
顺便我再提一提异常处理的注意点:
**1.尽量不要捕获类似Exception这样通用的异常，而应该捕获特定的异常**
软件工程是一门协作的艺术，在日常的开发中我们有义务使自己的代码能更直观、清晰的表达出我们想要表达的信息。
但是如果你什么异常都用了Exception，那别的开发同事就不能一眼得知这段代码实际想要捕获的异常，并且这样的
代码也会捕获到可能你希望它抛出而不希望捕获的异常。
**2.不要“吞”了异常**
如果我们捕获了异常，不把异常抛出，或者没有写到日志里，那会出现什么情况?线上除了bug 莫名其妙的没有任何的信息，
你都不知道哪里出错以及出错的原因。
这可能会让一个简单的bug变得难以诊断，而且有些同学比较喜欢用catch之后用e.printStackTrace()，在我们产品中
通常不推荐用这种方法，一般情况下这样是没有问题的但是这个方法输出的是个标准错误流。
比如是在分布式系统中，发生异常但是找不到stacktrace。
所以最好是输入到日志里，我们产品可以自定义一定的格式，将详细的信息输入到日志系统中，适合清晰高效的排查错误。
**3.不要延迟处理异常**
比如你有个方法，参数是个name，函数内部调了别的好几个方法，其实你的name传的是null值，但是你没有在进入这个
方法或者这个方法一开始就处理这个情况，而是在你调了别的好几个方法然后爆出这个空指针。
这样的话明明你的出错堆栈信息只需要抛出一点点信息就能定位到这个错误所在的地方，经过了好多方法之后可能就是一坨堆栈信息。
**4.只在需要try-catch的地方try-catch，try-catch的范围能小则小**
只要必要的代码段使用try-catch，不要不分青红皂白try住一坨代码，因为try-catch中的代码会影响JVM对代码的优化，例如重排序。
**5.不要通过异常来控制程序流程**
一些可以用if/else的条件语句来判断例如null值等，就不要用异常，异常肯定是比一些条件语句低效的，有CPU分支预测的优化等。
而且每实例化一个Exception都会对栈进行快照，相对而言这是一个比较重的操作，如果数量过多开销就不能被忽略了。
**6.不要在finally代码块中处理返回值或者直接return**
在 finally 中 return或者处理返回值会让发生很诡异的事情，比如覆盖了try中的return，或者屏蔽的异常。

## 9.Java面向对象编程与面向过程编程的区别是什么？
**面向对象编程**是一种编程范式或者说编程风格。**把类或对象作为基本单元织代码**，
并且运用提炼出的:封装、继承和多态来作为代码设计指导。
**面向过程编程**是以过程作为基本单元来组织代码的，过程其实就是动作，对应到代码中来就是函数，面向过程中和数据是分离的，数据其实就是成员变量。
面向过程其实就是一条道的思路，因为起初就是按计算机的思路来编写程序。
我就拿用咖啡机煮咖啡为例，按照面向过程的流程是:
>1.执行加咖啡豆方法  
2.执行加水方法  
3.执行煮咖啡方法  
4.执行喝咖啡方法  

很简单直观的操作，你可能没什么感觉，我再按面向对象思想来分析下这个流程。
在执行煮咖啡操作前要抽象出:人和咖啡机(分类)，然后开始执行:
>1.人.加咖啡豆  
2.人.加水  
3.咖啡机.煮  
4.人.喝咖啡

面向过程，从名字可以得知重点是过程，而面向对象的重点是对象。
从这个例子可以看出两者的不同:面向过程是很直接的思维，一步步的执行，一条道走到底。  
而面向对象是先抽象，把事物分类得到不同的类，划分每个类的职责，暴露出每个类所能执行的动作，然后按逻辑执行时调用每个类的方法即可，不关心内部的逻辑。  
从例子可以看出面向对象编程执行的步骤没有变少，整体执行流程还是一样的，都是先加咖啡豆、加水、煮咖啡、喝，这个逻辑没有变。
无非就是划分了类，把每一步骤具体的实现封装了起来，散布在不同的类中。  
对我们程序员来说是最最直接的感受:变的其实就是代码的分布，煮咖啡的代码实现被封装在咖啡机内部，喝咖啡的代码实现被封装在人内部，而不是在一个方法中写出来。  
代码的分布确实是最直观的，但是变得不仅只是分布，而是思想上的变化。
就是上面提到的计算机思维到人类思维的变化。 
这个变化是因为软件的发展，业务越来越复杂。 人们用面向过程语言编写复杂的软件时，需要按照不同的功能把一些数据和函数放到不同的文件中，渐渐地人们就发现这不就是先分类吗?  
并且好像业务分析下来都能和现实世界的东西对应上? 于是人们慢慢地总结、提炼就演变成了面向对象，再根据面向对象的特性提炼出关键点:封装、继承和多态。  
而这个面向对象思想就类似我们人类面对复杂场景时候的分析思维:归类、汇总。 所以面向对象编程就成为了现在主流的编程风格，因为符合人类的思考方式。  
面向过程编程和面向对象编程从思想上的变化是:从计算机思维转变成了人类的思维来编写编码。  
而面向对象编程的类中数据和动作是在一起的，这也是两者的一个显著的区别。

## 10.java方法重载和方法重写之间的区别是什么？
**直接回答**:
重载:在同一个类中定义多个方法，它们具有相同的名字但参数列表不同。主要用于提供相同功能的不同实现。  
重写:在子类中定义一个与父类方法具有相同签名的方法，以便提供子类的特定实现。主要用于实现运行时多态性。  
**扩展解析**:
重载:指在同一个类中定义多个方法，这些方法具有相同的名字但参数列表不同(参数类型、数量或顺序不同)。
***这里要注意和返回值没有关系***，方法的签名是名字和参数列表，不包括返回值。
***重载通常用于提供同一操作的不同实现，例如构造函数的重载、不同类型输入的处理等***。
重载简单示例代码:
```java
public class OverloadingExample {
    // 重载方法：参数数量不同
    public void print(int a) {
        System.out.println("Printing int: " + a);
    }

    // 重载方法：参数类型不同
    public void print(String a) {
        System.out.println("Printing String: " + a);
    }

    // 重载方法：参数类型和数量不同
    public void print(int a, int b) {
        System.out.println("Printing two ints: " + a + ", " + b);
    }
}
```
重写:指在子类中定义与父类方法具有相同签名(方法名、参数列表)的一个方法，方法返回类型与父类一致，或者是其子类(协变返回类型)。
且子类方法定义的访问修饰符，不能比父类更严格。例如父类方法是 protected，那么子类方法不能是 private ,但可以是public 。
且子类方法抛出的异常必须与父类一致，或者是其父类异常的子类。
重写通常用于在子类中提供父类方法的具体实现，以实现多态性。例如，子类对父类方法进行扩展或修改以适应特定需求。
重写简单示例代码:

```java
class Parent {
    public void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    @Override
    public void display() {
        System.out.println("Child display");
    }
}

public class OverridingExample {
    public static void main(String[] args) {
        Parent obj = new Child();
        obj.display(); // 输出 "Child display"
    }
}
```
### 总结
#### 重载
* 重载是指在同一个类中定义多个方法，它们具有相同的名字但参数列表不同
* 重载主要用于提供相同功能的不同实现，例如构造函数的重载
* 方法的签名是方法名和参数列表，不包括返回值
* 重载的判定只有方法签名这一条件:
  * 方法名一致
  * 形参列表不同(参数类型、数量或顺序不同)
### 重写
* 重写通常用于在子类中提供父类方法的具体实现，以实现多态性。例如，子类对父类方法进行扩展或修改以适应特定需求。
* 具体细说，就是子父类中的重写方法在对应的class文件常量池的位置相同，一旦子类没有重写，那么子类的实例就会沿着这个位置往上找，直到找到父类的同名方法
* 重写只发生在可见的实例方法中:
  * 静态方法不存在重写，形式上的重写只能说是隐藏。
  * 私有方法也不存在重写，父类中private的方法，子类中就算定义了，就是相当于一个新的方法。 
  * 静态方法和实例方法不存在相互重写
* 重写满足一个规则:两同 两小一大
  * 两同:方法名和形参列表一致
  * 两小:重写方法的返回值(引用类型)和抛出异常类型，要和被重写方法的相同或者是其子类。注意一旦返回值是基本数据类型，那么重写方法和被重写方法必须相同，且不存在自动拆装箱的问题
  * 一大:重写方法的访问修饰符>=被重写方法的访问修饰符